using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Detrecere
{
    public class Exploiter : Robot
    {
        List<Point> Path;
        public Point Target;
        public Point BaseLoc;

        public bool IsIdle;

        public int CollectAmmount = 3;

        public Exploiter(Point Position, Point Target, Point BaseLoc)
        {
            this.Position = Position;
            GetShortestPath(Target);
            IsIdle = false;
            this.BaseLoc = BaseLoc;

            color = Color.DarkOrange;
        }

        public override void Work()
        {
            if (Path.Count != 0)
            {
                Path.RemoveAt(Path.Count - 1);
                if (Path.Count - 1 >= 0)
                {
                    this.Position = Path[Path.Count - 1];
                }
                if (!IsIdle)
                {
                    Target = GetOreArround(this.Position);
                }
            }
            else if (IsIdle)
            {
                CalcHelper ch = new CalcHelper(Engine.Map);
                if(!ch.GetEmptyAround(BaseLoc).Contains(this.Position))
                {
                    GetShortestPath(BaseLoc);
                }
            }
            else
            {
                if (Engine.Map[Target.X, Target.Y].ResourceAmmount >= CollectAmmount)
                {
                    Engine.Map[Target.X, Target.Y].ResourceAmmount -= CollectAmmount;
                    Engine.Map[Target.X, Target.Y].AmmountOnTheGround += CollectAmmount;
                }
                else
                {
                    Engine.Map[Target.X, Target.Y].AmmountOnTheGround += Engine.Map[Target.X, Target.Y].ResourceAmmount;
                    Engine.Map[Target.X, Target.Y].ResourceAmmount = 0;
                    Engine.Map[Target.X, Target.Y].ContaintID = 0;
                    IsIdle = true;
                }
            }
        }

        private Point GetApprochablePoint(bool[,] map, Point t)
        {
            CHelper = new CalcHelper(Engine.Map);
            List<Point> ES = CHelper.GetEmptyAround(t);
            if (ES.Count != 0)
            {
                List<Point> Accesible = new List<Point>();
                for(int i=0;i<ES.Count;i++)
                {
                    if (CHelper.CalcShortestPath(Position, ES[i])!=null)
                    {
                        Accesible.Add(ES[i]);
                    }
                }
                if (Accesible.Count != 0)
                {
                    return Accesible[Engine.rnd.Next(Accesible.Count)];
                }
            }
            else
            {
                map[t.X, t.Y] = true;
                if (t.X - 1 >= 0 && !map[t.X - 1, t.Y])
                {
                    GetApprochablePoint(map, new Point(t.X - 1, t.Y));
                }
                if (t.Y - 1 >= 0 && !map[t.X, t.Y - 1])
                {
                    GetApprochablePoint(map, new Point(t.X, t.Y - 1));
                }
                if (t.X + 1 < Engine.MapSize && !map[t.X + 1, t.Y])
                {
                    GetApprochablePoint(map, new Point(t.X + 1, t.Y));
                }
                if (t.Y + 1 < Engine.MapSize && !map[t.X, t.Y + 1])
                {
                    GetApprochablePoint(map, new Point(t.X, t.Y + 1));
                }
            }
            return new Point(0, 0);
        }

        private Point GetOreArround(Point pos)
        {

             List<Point> p = new List<Point>();

            if (pos.X - 1 >= 0 && Engine.Map[pos.X - 1, pos.Y].ContaintID == (int)TileTipes.Iron && Engine.Visible[pos.X - 1, pos.Y])
            {
                p.Add(new Point(pos.X - 1, pos.Y));
            }

            if (pos.Y - 1 >= 0 && Engine.Map[pos.X, pos.Y - 1].ContaintID == (int)TileTipes.Iron && Engine.Visible[pos.X, pos.Y - 1])
            {
                p.Add(new Point(pos.X, pos.Y - 1));
            }

            if (pos.X + 1 < Engine.Map.GetLength(0) && Engine.Map[pos.X + 1, pos.Y].ContaintID == (int)TileTipes.Iron && Engine.Visible[pos.X + 1, pos.Y])
            {
                p.Add(new Point(pos.X + 1, pos.Y));
            }

            if (pos.Y + 1 < Engine.Map.GetLength(1) && Engine.Map[pos.X, pos.Y + 1].ContaintID == (int)TileTipes.Iron && Engine.Visible[pos.X, pos.Y + 1])
            {
                p.Add(new Point(pos.X, pos.Y + 1));
            }

            if (p.Count <= 0)
            {
                IsIdle = true;
                return new Point(0, 0);
            }
            else
            {
                return p[Engine.rnd.Next(p.Count)];
            }
            
        }

        public void GetShortestPath(Point TargetLocation)
        {
            Path = new List<Point>();
            CHelper = new CalcHelper(Engine.Map);
            bool[,] map = new bool[Engine.MapSize, Engine.MapSize];
            Target =TargetLocation;
            Path = CHelper.CalcShortestPath(Position, GetApprochablePoint(map, Target));
            //Target = GetOreArround(GetOreArround(Path[0]));
        }
    }
}
